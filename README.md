# 

# Биржевой стакан

## Вариант первый

Тут используется std::set


Это первое, что пришло в голову, поскольку в основном нам нужны лучшие заявки, а в set доступ к ним линейный по количеству запрашиваемых элементов (в данной задаче - константа, т.к. кол-во запрашиваемых эл-тов 10).
Вставка, удаление и редактирование за логарифм. 
Поскольку вставка и поиск в std::set логарифмические по размеру контейнера.

## Вариант второй

Тут используется std::vector

Главное преимущество - вставка за константу. Удаление - линейно по размеру контейнера, для поиска нужного элемента приходится пробежаться по всем, и сам erase для вектора линейный. 
Изменение также линейно, поскольку тут также ищем элемент. 
Поиск 10 лучших также линейный, но с очень большой константой (в том варианте, который в итоговой версии, мы N раз сортируем массив из 10 элементов).
В предыдущем варианте был вариант - изначальная сортировка массива из N элементов. 
Но я всё-таки отдал предпочтение первому варианту, поскольку на популярные акции заявок может быть в очень много раз больше (наверное).

## Класс проверки стаканов

Надеюсь я правильно понял, что нужны не тесты с возможностью генерации отчета и т.д., а консольное приложение.
Сделан шаблонный класс, в котором: первые четыре метода замеряют время выполнения операций вставки, удаления, изменения и получения без проверки на корректность. 
Далее проверка вставки и чтения. Далее проверки удаления и модификации. 
По результату каждый метод выводит в стандартный вывод информацию (время выполнения или успешность проверки)

## Вывод

В целом результаты замеров сходятся с ожиданиями.
Если нужно постоянно добавлять новые заявки - то однозначный фаворит второй вариант. 
Подозреваю, что люди гораздо чаще смотрят цены, чем делают заявки, а значит получение информации о лучших предложений за константу - то что нужно.
